import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as t,o as h,c,d as o,a,e as s,b as i,f as n}from"./app-qKT_MvSj.js";const r={},p=a("h2",{id:"树",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#树"},[a("span",null,"树")])],-1),m={href:"https://www.cnblogs.com/maybe2030/p/4732377.html",target:"_blank",rel:"noopener noreferrer"},d=n('<p>树是一种非常重要的数据结构。类似于链表，树中的结点也是通过结点自带的指针相连。通常来说，树只有一个根结点，其余每个结点只有一个父结点。除了叶子结点之外，每个结点都有一个或多个孩子结点。</p><h2 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树"><span>二叉树</span></a></h2><p>二叉树是树结构中最基础的一种结构，其中每个结点最多有两个子结点。</p><p>二叉树还有两种特殊情况：</p><ul><li>满二叉树：树中所有的叶子结点都位于树的最底层，其他层的所有结点均有两个子结点。换句话说，在当前的高度下，树中每一层的结点数量都达到最大值。</li><li>完全二叉树：树中最底层的所有结点连续出现在最左边，其他层的结点数量都达到最大值。</li></ul><p>一般的二叉树没有太多具体的用途，因为其中的结点没有规律。举个例子，如果要查找二叉树中是否包含某个值，只能遍历所有结点进行检查。</p><h2 id="二叉搜索树" tabindex="-1"><a class="header-anchor" href="#二叉搜索树"><span>二叉搜索树</span></a></h2><p>二叉搜索树，也称为二叉查找树，是一种特殊的二叉树。相比一般的二叉树，二叉搜索树可以提高访问效率。</p><p>二叉搜索树的性质包括：</p><ul><li>没有值相等的结点。</li><li>对于任意一个结点，其值大于左子结点的值，小于右子结点的值。</li></ul><p>对于二叉搜索树，一般有三种操作：</p><ul><li>查找：类似于二分查找。</li><li>插入：依赖查找操作，在进行插入。</li><li>删除：依赖查找操作，如果存在再进行删除。</li></ul>',12),u=a("p",null,[s("假设二叉搜索树的高度为"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"n")]),a("annotation",{encoding:"application/x-tex"},"n")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.4306em"}}),a("span",{class:"mord mathnormal"},"n")])])]),s("，查找的平均时间复杂度为 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"lg"),a("mo",null,"⁡"),a("mi",null,"n"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(\\lg{n})")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mop"},[s("l"),a("span",{style:{"margin-right":"0.01389em"}},"g")]),a("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),a("span",{class:"mord"},[a("span",{class:"mord mathnormal"},"n")]),a("span",{class:"mclose"},")")])])]),s("。当二叉搜索树退化为单链表时（最坏情况），此时查找效率为 "),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"n"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(n)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mclose"},")")])])]),s("。插入和删除的时间复杂度依赖于查找操作。")],-1),x=a("h2",{id:"平衡二叉树",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#平衡二叉树"},[a("span",null,"平衡二叉树")])],-1),g=a("p",null,"平衡二叉树是指平衡的二叉树，其中的“平衡”是通过限制树中每个结点的左子树和右子树的高度来实现的。因为一般的二叉树用处不大，所以“平衡”这一性质主要应用在二叉搜索树上。",-1),_=a("p",null,"平衡二叉搜索树主要是为了解决一般的二叉搜索树存在退化的问题。当二叉搜索树退化为单链表时，查找效率急剧下降。",-1),f=a("p",null,"平衡二叉搜索树有多种不同的实现，比如 AVL 树、红黑树等。",-1),w=a("h3",{id:"avl-树",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#avl-树"},[a("span",null,"AVL 树")])],-1),b=a("p",null,"AVL 树是最早发明的平衡二叉搜索树。在AVL树中，每个结点的左子树和右子树的深度之差的绝对值不超过1。因此，AVL树是高度平衡的。",-1),k=a("p",null,[s("假设AVL树的高度为"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"n")]),a("annotation",{encoding:"application/x-tex"},"n")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.4306em"}}),a("span",{class:"mord mathnormal"},"n")])])]),s("，查找、插入和删除在平均和最坏情况下的时间复杂度都是"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"lg"),a("mo",null,"⁡"),a("mi",null,"n"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(\\lg{n})")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mop"},[s("l"),a("span",{style:{"margin-right":"0.01389em"}},"g")]),a("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),a("span",{class:"mord"},[a("span",{class:"mord mathnormal"},"n")]),a("span",{class:"mclose"},")")])])]),s("。")],-1),y=n('<h3 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树"><span>红黑树</span></a></h3><h2 id="多叉树-n叉树" tabindex="-1"><a class="header-anchor" href="#多叉树-n叉树"><span>多叉树（N叉树）</span></a></h2><h3 id="b树" tabindex="-1"><a class="header-anchor" href="#b树"><span>B树</span></a></h3><h3 id="b-树" tabindex="-1"><a class="header-anchor" href="#b-树"><span>B+树</span></a></h3><h2 id="堆" tabindex="-1"><a class="header-anchor" href="#堆"><span>堆</span></a></h2><p>堆是一种特殊的完全二叉树，其中树中的所有结点存放在一个数组中，每一个结点对应了数组中的一个元素。堆中的结点没有使用指针相连，而是通过数组的下标来建立父子关系，因此空间效率比较高。</p><p>结点之间的关系如下：对于下标为<code>i</code>的结点，如果下标从0开始，那么左子结点和右子结点的下标分别是<code>2*i+1</code>和<code>2*i+2</code>。</p><p>普通的堆通常没有太大的实际意义，所以总是使用有一定规律的堆，比如</p><ul><li>最大堆：对于任意一个结点，其值大于子结点的值。</li><li>最小堆：对于任意一个结点，其值小于子结点的值。</li></ul><h2 id="字典树" tabindex="-1"><a class="header-anchor" href="#字典树"><span>字典树</span></a></h2><h2 id="线段树" tabindex="-1"><a class="header-anchor" href="#线段树"><span>线段树</span></a></h2><h2 id="树状数组" tabindex="-1"><a class="header-anchor" href="#树状数组"><span>树状数组</span></a></h2>',12);function M(L,V){const l=t("ExternalLinkIcon");return h(),c("div",null,[o(" more "),p,a("blockquote",null,[a("p",null,[a("a",m,[s("[Data Structure] 数据结构中各种树"),i(l)])])]),d,u,x,g,_,f,w,b,k,y])}const A=e(r,[["render",M],["__file","intro.html.vue"]]);export{A as default};
