import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as o,o as c,c as l,d as i,a as n,e as s,b as p,f as t}from"./app-qKT_MvSj.js";const u={},r=t(`<h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span>基础</span></a></h2><h3 id="树节点" tabindex="-1"><a class="header-anchor" href="#树节点"><span>树节点</span></a></h3><p>1）Python</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">,</span> left<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val
        self<span class="token punctuation">.</span>left <span class="token operator">=</span> left
        self<span class="token punctuation">.</span>right <span class="token operator">=</span> right
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="leetcode-编程题" tabindex="-1"><a class="header-anchor" href="#leetcode-编程题"><span>Leetcode 编程题</span></a></h2><h3 id="_144-二叉树的前序遍历" tabindex="-1"><a class="header-anchor" href="#_144-二叉树的前序遍历"><span>144. 二叉树的前序遍历</span></a></h3>`,6),k={href:"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/",title:"144. 二叉树的前序遍历",target:"_blank",rel:"noopener noreferrer"},d=t(`<p>遍历顺序：父节点，左子树，右子树。</p><p>1）递归版本</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> root<span class="token punctuation">:</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            left <span class="token operator">=</span> self<span class="token punctuation">.</span>preorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>left<span class="token punctuation">)</span>
            right <span class="token operator">=</span> self<span class="token punctuation">.</span>preorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）非递归版本</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        node <span class="token operator">=</span> root
        
        <span class="token keyword">while</span> stack <span class="token keyword">or</span> node<span class="token punctuation">:</span>
            <span class="token keyword">if</span> node<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>left
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>right
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3）非递归版本</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>
        
        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
            node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_94-二叉树的中序遍历" tabindex="-1"><a class="header-anchor" href="#_94-二叉树的中序遍历"><span>94. 二叉树的中序遍历</span></a></h3>`,8),v={href:"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/",title:"94. 二叉树的中序遍历",target:"_blank",rel:"noopener noreferrer"},m=t(`<p>遍历顺序：左子树，父节点，右子树。</p><p>1）递归版本</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> root<span class="token punctuation">:</span>
            left <span class="token operator">=</span> self<span class="token punctuation">.</span>inorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>left<span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            right <span class="token operator">=</span> self<span class="token punctuation">.</span>inorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）非递归版本</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        node <span class="token operator">=</span> root
        
        <span class="token keyword">while</span> stack <span class="token keyword">or</span> node<span class="token punctuation">:</span>
            <span class="token keyword">if</span> node<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>left
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>right
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),b=n("p",null,[s("3）非递归版本。Morris中序遍历，空间复杂度"),n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mn",null,"1"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(1)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord"},"1"),n("span",{class:"mclose"},")")])])]),s("。")],-1),h=n("p",null,[n("mark",null,"TODO")],-1),y=n("h3",{id:"_145-二叉树的后序遍历",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_145-二叉树的后序遍历"},[n("span",null,"145. 二叉树的后序遍历")])],-1),f={href:"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/",title:"145. 二叉树的后序遍历",target:"_blank",rel:"noopener noreferrer"},w=t(`<p>遍历顺序：左子树，右子树，父节点。</p><p>1）递归版本</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> root<span class="token punctuation">:</span>
            left <span class="token operator">=</span> self<span class="token punctuation">.</span>postorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>left<span class="token punctuation">)</span>
            right <span class="token operator">=</span> self<span class="token punctuation">.</span>postorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>right<span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）非递归版本。推荐方法。</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        
        res <span class="token operator">=</span>  <span class="token punctuation">[</span><span class="token punctuation">]</span>
        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        node <span class="token operator">=</span> root
        visited <span class="token operator">=</span> <span class="token boolean">None</span>  <span class="token comment"># 用来标记已访问的结点</span>

        <span class="token keyword">while</span> stack <span class="token keyword">or</span> node<span class="token punctuation">:</span>
            <span class="token keyword">if</span> node<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>left
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  
                <span class="token comment"># 关键：栈中最后一个结点，并检查该结点的右孩子是否为空或者刚被访问</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> visited<span class="token punctuation">:</span> 
                    node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token comment"># 访问该结点，并标记被访问</span>
                    visited <span class="token operator">=</span> node
                    node <span class="token operator">=</span> <span class="token boolean">None</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    node <span class="token operator">=</span> node<span class="token punctuation">.</span>right  <span class="token comment"># 在右子树进行一次后序遍历</span>
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3）非递归版本。该方法与前序遍历第 3 种方法类似。</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
            node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    
        <span class="token keyword">return</span> res<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_102-二叉树的层序遍历" tabindex="-1"><a class="header-anchor" href="#_102-二叉树的层序遍历"><span>102. 二叉树的层序遍历</span></a></h3>`,8),g={href:"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/",title:"102. 二叉树的层序遍历",target:"_blank",rel:"noopener noreferrer"},_=t(`<p>一、题目</p><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。（即逐层地，从左到右访问所有节点）。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>
        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
            cur_level_vals <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            next_level_nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">:</span>
                cur_level_vals<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> 
                    next_level_nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> 
                    next_level_nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur_level_vals<span class="token punctuation">)</span>
            queue <span class="token operator">=</span> next_level_nodes
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_102-1-二叉树的层序遍历ii" tabindex="-1"><a class="header-anchor" href="#_102-1-二叉树的层序遍历ii"><span>102-1. 二叉树的层序遍历II</span></a></h3><p>返回一个列表。</p><p>1）不会往队列中添加空结点。</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        
        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 双向队列deque</span>
        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
            node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> 
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> 
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）会往队列中添加空结点。</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 双向队列deque</span>
        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
            node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">pass</span>  <span class="token comment"># 可以进行一些操作</span>
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_103-锯齿形层序遍历" tabindex="-1"><a class="header-anchor" href="#_103-锯齿形层序遍历"><span>103. 锯齿形层序遍历</span></a></h3>`,12),q={href:"https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/",target:"_blank",rel:"noopener noreferrer"},x=t(`<p>一、题目</p><p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">zigzagLevelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        ordered <span class="token operator">=</span> <span class="token boolean">True</span>
        queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>
        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
            cur_level_vals <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            next_level_nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> node <span class="token keyword">in</span> queue<span class="token punctuation">:</span>
                cur_level_vals<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> 
                    next_level_nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> 
                    next_level_nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">if</span> ordered<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur_level_vals<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur_level_vals<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            ordered <span class="token operator">=</span> <span class="token keyword">not</span> ordered
            queue <span class="token operator">=</span> next_level_nodes
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_235-二叉搜索树的最近公共祖先" tabindex="-1"><a class="header-anchor" href="#_235-二叉搜索树的最近公共祖先"><span>235. 二叉搜索树的最近公共祖先</span></a></h3>`,6),N={href:"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",title:"235. 二叉搜索树的最近公共祖先",target:"_blank",rel:"noopener noreferrer"},T=t(`<p>一、题目</p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token string">&#39;TreeNode&#39;</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        
        <span class="token keyword">if</span> root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> p<span class="token punctuation">.</span>val <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>val <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_236-二叉树的最近公共祖先" tabindex="-1"><a class="header-anchor" href="#_236-二叉树的最近公共祖先"><span>236. 二叉树的最近公共祖先</span></a></h3>`,7),S={href:"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/",title:"236. 二叉树的最近公共祖先",target:"_blank",rel:"noopener noreferrer"},L=t(`<p>一、题目</p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> p<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> q<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root <span class="token keyword">or</span> root <span class="token operator">==</span> p <span class="token keyword">or</span> root <span class="token operator">==</span> q<span class="token punctuation">:</span>
            <span class="token keyword">return</span> root
        
        left <span class="token operator">=</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
        right <span class="token operator">=</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> left <span class="token keyword">and</span> <span class="token keyword">not</span> right<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token keyword">elif</span> <span class="token keyword">not</span> left<span class="token punctuation">:</span>
            <span class="token keyword">return</span> right
        <span class="token keyword">elif</span> <span class="token keyword">not</span> right<span class="token punctuation">:</span>
            <span class="token keyword">return</span> left
        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_257-二叉树的所有路径" tabindex="-1"><a class="header-anchor" href="#_257-二叉树的所有路径"><span>257. 二叉树的所有路径</span></a></h3>`,6),B={href:"https://leetcode-cn.com/problems/binary-tree-paths/",title:"257. 二叉树的所有路径",target:"_blank",rel:"noopener noreferrer"},I=t(`<p>一、题目</p><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>二、解析</p><p>利用层序遍历。访问到叶子结点时需要保存结果，也可以在 if 条件中添加判断条件。</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">binaryTreePaths</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        
        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        node_queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
        path_queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> node_queue<span class="token punctuation">:</span>
            node <span class="token operator">=</span> node_queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            path <span class="token operator">=</span> path_queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                node_queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                path_queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path <span class="token operator">+</span> <span class="token string">&#39;-&gt;&#39;</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                node_queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                path_queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path <span class="token operator">+</span> <span class="token string">&#39;-&gt;&#39;</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_112-路经总和" tabindex="-1"><a class="header-anchor" href="#_112-路经总和"><span>112. 路经总和</span></a></h3>`,7),O={href:"https://leetcode-cn.com/problems/path-sum/",title:"112. 路径总和",target:"_blank",rel:"noopener noreferrer"},z=t(`<p>一、题目</p><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>二、解析</p><p>1）使用模板</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        
        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        node_queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
        path_queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> node_queue<span class="token punctuation">:</span>
            node <span class="token operator">=</span> node_queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            path <span class="token operator">=</span> path_queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                node_queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                path_queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path <span class="token operator">+</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                node_queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                path_queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>right <span class="token keyword">and</span> path <span class="token operator">==</span> s<span class="token punctuation">:</span> <span class="token comment"># 叶子节点</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span> 
        <span class="token keyword">return</span> <span class="token boolean">False</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）递归</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>

        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>right<span class="token punctuation">:</span>  <span class="token comment"># if reach a leaf</span>
            <span class="token keyword">return</span> s <span class="token operator">-</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> <span class="token number">0</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>hasPathSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> s <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>hasPathSum<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> s <span class="token operator">-</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_113-路径总和-ii" tabindex="-1"><a class="header-anchor" href="#_113-路径总和-ii"><span>113. 路径总和 II</span></a></h3>`,9),A={href:"https://leetcode-cn.com/problems/path-sum-ii/",title:"113. 路径总和 II",target:"_blank",rel:"noopener noreferrer"},C=t(`<p>一、题目</p><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>二、解析</p><p>1）使用模板</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        node_queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
        path_queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> node_queue<span class="token punctuation">:</span>
            node <span class="token operator">=</span> node_queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            path <span class="token operator">=</span> path_queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                node_queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                path_queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path <span class="token operator">+</span> <span class="token punctuation">[</span>node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                node_queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                path_queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path <span class="token operator">+</span> <span class="token punctuation">[</span>node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>right <span class="token keyword">and</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">)</span>
        
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、递归</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">get_all_path</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">elif</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                <span class="token keyword">return</span><span class="token punctuation">[</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">]</span>

            left <span class="token operator">=</span> get_all_path<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            right <span class="token operator">=</span> get_all_path<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">+</span> path <span class="token keyword">for</span> path <span class="token keyword">in</span> left <span class="token operator">+</span> right<span class="token punctuation">]</span>
        
        res <span class="token operator">=</span> get_all_path<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span>path <span class="token keyword">for</span> path <span class="token keyword">in</span> res <span class="token keyword">if</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_437-路径总和-iii" tabindex="-1"><a class="header-anchor" href="#_437-路径总和-iii"><span>437. 路径总和 III</span></a></h3>`,9),P={href:"https://leetcode-cn.com/problems/path-sum-iii/",title:"437. 路径总和 III",target:"_blank",rel:"noopener noreferrer"},F=t(`<p>一、题目</p><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span>  <span class="token comment"># path_sum, count</span>
            left <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
            right <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
            path_sum <span class="token operator">=</span> <span class="token punctuation">[</span>ps <span class="token operator">+</span> node<span class="token punctuation">.</span>val <span class="token keyword">for</span> ps <span class="token keyword">in</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>node<span class="token punctuation">.</span>val<span class="token punctuation">]</span>
            count <span class="token operator">=</span> left<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> right<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> ps <span class="token keyword">in</span> path_sum<span class="token punctuation">:</span>
                <span class="token keyword">if</span> ps <span class="token operator">==</span> target<span class="token punctuation">:</span>
                    count <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">return</span> path_sum<span class="token punctuation">,</span> count
        
        <span class="token keyword">return</span> helper<span class="token punctuation">(</span>root<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>递归函数不返回目标变量，而是直接在内部修改，递归更简洁。</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># path_sum</span>
            <span class="token keyword">nonlocal</span> res
            left <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
            right <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
            path_sum <span class="token operator">=</span> <span class="token punctuation">[</span>ps <span class="token operator">+</span> node<span class="token punctuation">.</span>val <span class="token keyword">for</span> ps <span class="token keyword">in</span> left <span class="token operator">+</span> right<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>node<span class="token punctuation">.</span>val<span class="token punctuation">]</span>
            <span class="token keyword">for</span> ps <span class="token keyword">in</span> path_sum<span class="token punctuation">:</span>
                <span class="token keyword">if</span> ps <span class="token operator">==</span> target<span class="token punctuation">:</span>
                    res <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">return</span> path_sum
        
        res <span class="token operator">=</span> <span class="token number">0</span>
        helper<span class="token punctuation">(</span>root<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_105-从前序与中序遍历序列构造二叉树" tabindex="-1"><a class="header-anchor" href="#_105-从前序与中序遍历序列构造二叉树"><span>105. 从前序与中序遍历序列构造二叉树</span></a></h3>`,9),R={href:"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",title:"105. 从前序与中序遍历序列构造二叉树",target:"_blank",rel:"noopener noreferrer"},D=t(`<p>一、题目</p><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意：你可以假设树中没有重复的元素。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> preorder<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">None</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preorder<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

            index <span class="token operator">=</span> inorder<span class="token punctuation">.</span>index<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            root<span class="token punctuation">.</span>left <span class="token operator">=</span> helper<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>
            root<span class="token punctuation">.</span>right <span class="token operator">=</span> helper<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inorder<span class="token punctuation">[</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> root

        <span class="token keyword">return</span> helper<span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_106-从中序与后序遍历序列构造二叉树" tabindex="-1"><a class="header-anchor" href="#_106-从中序与后序遍历序列构造二叉树"><span>106. 从中序与后序遍历序列构造二叉树</span></a></h3>`,7),V={href:"https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/",title:"106. 从中序与后序遍历序列构造二叉树",target:"_blank",rel:"noopener noreferrer"},j=t(`<p>一、题目</p><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:你可以假设树中没有重复的元素。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> postorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> inorder<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">None</span>
            <span class="token keyword">elif</span> <span class="token builtin">len</span><span class="token punctuation">(</span>inorder<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> TreeNode<span class="token punctuation">(</span>inorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

            root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>postorder<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            index <span class="token operator">=</span> inorder<span class="token punctuation">.</span>index<span class="token punctuation">(</span>postorder<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            n_right <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>inorder<span class="token punctuation">)</span> <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span>
            root<span class="token punctuation">.</span>left <span class="token operator">=</span> helper<span class="token punctuation">(</span>inorder<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> postorder<span class="token punctuation">[</span><span class="token punctuation">:</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>
            root<span class="token punctuation">.</span>right <span class="token operator">=</span> helper<span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> postorder<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">-</span> n_right<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> root

        <span class="token keyword">return</span> helper<span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_889-根据前序和后序遍历构造二叉树" tabindex="-1"><a class="header-anchor" href="#_889-根据前序和后序遍历构造二叉树"><span>889. 根据前序和后序遍历构造二叉树</span></a></h3>`,7),E={href:"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/",title:"889. 根据前序和后序遍历构造二叉树",target:"_blank",rel:"noopener noreferrer"},M=t(`<p>一、题目</p><p>返回与给定的前序和后序遍历匹配的任何二叉树。</p><p>pre 和 post 遍历中的值是不同的正整数。长度相等。</p><p>每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">constructFromPrePost</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pre<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> post<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> post<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> pre <span class="token keyword">or</span> <span class="token keyword">not</span> post <span class="token keyword">or</span> <span class="token builtin">len</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>post<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">None</span>
            
            root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> root
            
            index <span class="token operator">=</span> post<span class="token punctuation">.</span>index<span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            count <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span>
            
            root<span class="token punctuation">.</span>left <span class="token operator">=</span> helper<span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">1</span> <span class="token punctuation">:</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> post<span class="token punctuation">[</span><span class="token punctuation">:</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span>
            root<span class="token punctuation">.</span>right <span class="token operator">=</span> helper<span class="token punctuation">(</span>pre<span class="token punctuation">[</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> post<span class="token punctuation">[</span>count<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> root

        <span class="token keyword">return</span> helper<span class="token punctuation">(</span>pre<span class="token punctuation">,</span> post<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1028-从先序遍历还原二叉树" tabindex="-1"><a class="header-anchor" href="#_1028-从先序遍历还原二叉树"><span>1028. 从先序遍历还原二叉树</span></a></h3>`,8),G={href:"https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/",title:"1028. 从先序遍历还原二叉树",target:"_blank",rel:"noopener noreferrer"},H=t(`<p>一、题目</p><p>我们从二叉树的根节点<code>root</code>开始进行深度优先搜索。</p><p>在遍历中的每个节点处，我们输出<code>D</code>条短划线（其中<code>D</code>是该节点的深度），然后输出该节点的值。（如果节点的深度为<code>D</code>，则其直接子节点的深度为<code>D + 1</code>。根节点的深度为<code>0</code>）。</p><p>如果节点只有一个子节点，那么保证该子节点为左子节点。</p><p>给出遍历输出<code>S</code>，还原树并返回其根节点<code>root</code>。</p><p>示例：</p><div class="language-纯文本 line-numbers-mode" data-ext="纯文本" data-title="纯文本"><pre class="language-纯文本"><code>输入：&quot;1-2--3--4-5--6--7&quot;

对应的二叉树：
         1
       /   \\
      2     5
     / \\   / \\
    3   4 6   7
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>二、解析</p><p>1）栈模拟。</p>`,9),J={href:"https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/solution/cong-xian-xu-bian-li-huan-yuan-er-cha-shu-by-leetc/",title:"Leetcode官方题解",target:"_blank",rel:"noopener noreferrer"},K=t(`<p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">recoverFromPreorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> S<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        pos <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> pos <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">:</span>
            level <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">while</span> S<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">&#39;-&#39;</span><span class="token punctuation">:</span>
                level <span class="token operator">+=</span> <span class="token number">1</span>
                pos <span class="token operator">+=</span> <span class="token number">1</span>
            value <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">while</span> pos <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token keyword">and</span> S<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                value <span class="token operator">=</span> value <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>S<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">&#39;0&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                pos <span class="token operator">+=</span> <span class="token number">1</span>
            node <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
            <span class="token keyword">if</span> level <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> stack<span class="token punctuation">:</span>
                    stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>left <span class="token operator">=</span> node
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                stack <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token punctuation">:</span>level<span class="token punctuation">]</span>
                stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>right <span class="token operator">=</span> node
            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
        <span class="token keyword">return</span> stack<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）用哈希表，更容易理解。</p>`,3),Q={href:"https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/comments/450316",title:"Leetcode-Actonmic",target:"_blank",rel:"noopener noreferrer"},U=t(`<p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">recoverFromPreorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> S<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        pos <span class="token operator">=</span> <span class="token number">0</span>
        saved <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token boolean">None</span><span class="token punctuation">}</span>
        <span class="token keyword">while</span> pos <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">:</span>
            level <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">while</span> S<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">&#39;-&#39;</span><span class="token punctuation">:</span>
                level <span class="token operator">+=</span> <span class="token number">1</span>
                pos <span class="token operator">+=</span> <span class="token number">1</span>
            value <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">while</span> pos <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token keyword">and</span> S<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                value <span class="token operator">=</span> value <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>S<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">&#39;0&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                pos <span class="token operator">+=</span> <span class="token number">1</span>
            node <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
            <span class="token keyword">if</span> level <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                saved<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> node
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                parent <span class="token operator">=</span> saved<span class="token punctuation">[</span>level <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                <span class="token keyword">if</span> parent<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                    parent<span class="token punctuation">.</span>left <span class="token operator">=</span> node
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    parent<span class="token punctuation">.</span>right <span class="token operator">=</span> node
                saved<span class="token punctuation">[</span>level<span class="token punctuation">]</span> <span class="token operator">=</span> node
        <span class="token keyword">return</span> saved<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1008-先序遍历构造二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_1008-先序遍历构造二叉搜索树"><span>1008. 先序遍历构造二叉搜索树</span></a></h3>`,3),W={href:"https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/comments/",title:"1008. 先序遍历构造二叉树",target:"_blank",rel:"noopener noreferrer"},X=t(`<p>一、题目</p><p>返回与给定先序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。</p><p>二、解析</p><p>根据先序遍历构造二叉搜索树。</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">bstFromPreorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>preorder<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> preorder<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">None</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preorder<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

            root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            begin<span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span>
            <span class="token keyword">while</span> end <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>preorder<span class="token punctuation">)</span> <span class="token keyword">and</span> preorder<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&lt;</span> preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                end <span class="token operator">+=</span> <span class="token number">1</span>
            
            root<span class="token punctuation">.</span>left <span class="token operator">=</span> helper<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>begin<span class="token punctuation">:</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span>
            root<span class="token punctuation">.</span>right <span class="token operator">=</span> helper<span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>end<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> root
        
        <span class="token keyword">return</span> helper<span class="token punctuation">(</span>preorder<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_104-二叉树的最大深度" tabindex="-1"><a class="header-anchor" href="#_104-二叉树的最大深度"><span>104. 二叉树的最大深度</span></a></h3>`,7),Y={href:"https://leetcode.cn/problems/maximum-depth-of-binary-tree/",target:"_blank",rel:"noopener noreferrer"},Z=t(`<p>一、题目</p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：给定二叉树 [3,9,20,null,null,15,7]，</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code>    <span class="token number">3</span>
   <span class="token operator">/</span> \\
  <span class="token number">9</span>  <span class="token number">20</span>
    <span class="token operator">/</span>  \\
   <span class="token number">15</span>   <span class="token number">7</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回它的最大深度 3 。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token number">0</span>
            left <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            right <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">return</span> helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_110-平衡二叉树" tabindex="-1"><a class="header-anchor" href="#_110-平衡二叉树"><span>110. 平衡二叉树</span></a></h3>`,11),$={href:"https://leetcode-cn.com/problems/balanced-binary-tree/",title:"110. 平衡二叉树",target:"_blank",rel:"noopener noreferrer"},nn=t(`<p>一、题目</p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">True</span>  <span class="token comment"># depth, is_balance</span>
            left <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            right <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            depth <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
            is_balance <span class="token operator">=</span> left<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> right<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span>
            <span class="token keyword">return</span> depth<span class="token punctuation">,</span> is_balance
        <span class="token keyword">return</span> helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_543-二叉树中的直径" tabindex="-1"><a class="header-anchor" href="#_543-二叉树中的直径"><span>543. 二叉树中的直径</span></a></h3>`,7),sn={href:"https://leetcode-cn.com/problems/diameter-of-binary-tree/",title:"543. 二叉树的直径",target:"_blank",rel:"noopener noreferrer"},an=t(`<p>一、题目</p><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">diameterOfBinaryTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>  <span class="token comment"># depth, diameter</span>
            left <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            right <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            depth <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
            diameter <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> left<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> right<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> depth<span class="token punctuation">,</span> diameter
        <span class="token keyword">return</span> helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_536-二叉树的坡度" tabindex="-1"><a class="header-anchor" href="#_536-二叉树的坡度"><span>536. 二叉树的坡度</span></a></h3>`,6),pn={href:"https://leetcode-cn.com/problems/binary-tree-tilt/",title:"563. 二叉树的坡度",target:"_blank",rel:"noopener noreferrer"},tn=t(`<p>一、题目</p><p>给定一个二叉树，计算整个树的坡度。</p><p>一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。</p><p>整个树的坡度就是其所有节点的坡度之和。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findTilt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token comment"># sum, tilt</span>
            left <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            right <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            sum_ <span class="token operator">=</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> node<span class="token punctuation">.</span>val
            tilt <span class="token operator">=</span> left<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> right<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> sum_<span class="token punctuation">,</span> tilt  
        <span class="token keyword">return</span> helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_124-二叉树中的最大路径和" tabindex="-1"><a class="header-anchor" href="#_124-二叉树中的最大路径和"><span>124. 二叉树中的最大路径和</span></a></h3>`,8),en={href:"https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/",title:"124. 二叉树中的最大路径和",target:"_blank",rel:"noopener noreferrer"},on=t(`<p>一、题目</p><p>给定一个非空二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><p>二、解析</p><p>如果当前结点的值小于0，那么路径可以不包含当前结点，当前路径的和最小为0。</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&quot;-inf&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span>  <span class="token comment"># res, the larger sum</span>
            left <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            right <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            left_sum <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> left<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            right_sum <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> right<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> left_sum <span class="token operator">+</span> node<span class="token punctuation">.</span>val <span class="token operator">+</span> right_sum<span class="token punctuation">)</span>
            larger_sum <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>left_sum<span class="token punctuation">,</span> right_sum<span class="token punctuation">)</span> <span class="token operator">+</span> node<span class="token punctuation">.</span>val
            <span class="token keyword">return</span> res<span class="token punctuation">,</span> larger_sum

        <span class="token keyword">return</span> helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>递归函数不返回目标变量，而是直接在内部修改，递归更简洁。</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token number">0</span>
            <span class="token keyword">nonlocal</span> res
            left <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            right <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            left_sum <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> left<span class="token punctuation">)</span>
            right_sum <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>
            res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> left_sum <span class="token operator">+</span> node<span class="token punctuation">.</span>val <span class="token operator">+</span> right_sum<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>left_sum<span class="token punctuation">,</span> right_sum<span class="token punctuation">)</span> <span class="token operator">+</span> node<span class="token punctuation">.</span>val
        
        res <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">&#39;-inf&#39;</span><span class="token punctuation">)</span>
        maxPath<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_437-路径总和-iii-1" tabindex="-1"><a class="header-anchor" href="#_437-路径总和-iii-1"><span>437. 路径总和 III</span></a></h3>`,10),cn={href:"https://leetcode-cn.com/problems/path-sum-iii/",title:"437. 路径总和 III",target:"_blank",rel:"noopener noreferrer"},ln=t(`<p>一、题目</p><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span>  <span class="token comment"># path_sum, count</span>
            left <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
            right <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
            path_sum <span class="token operator">=</span> <span class="token punctuation">[</span>ps <span class="token operator">+</span> node<span class="token punctuation">.</span>val <span class="token keyword">for</span> ps <span class="token keyword">in</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>node<span class="token punctuation">.</span>val<span class="token punctuation">]</span>
            count <span class="token operator">=</span> left<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> right<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> ps <span class="token keyword">in</span> path_sum<span class="token punctuation">:</span>
                <span class="token keyword">if</span> ps <span class="token operator">==</span> target<span class="token punctuation">:</span>
                    count <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">return</span> path_sum<span class="token punctuation">,</span> count
        
        <span class="token keyword">return</span> helper<span class="token punctuation">(</span>root<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>递归函数不返回目标变量，而是直接在内部修改，递归更简洁。</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># path_sum</span>
            <span class="token keyword">nonlocal</span> res
            left <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
            right <span class="token operator">=</span> helper<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
            path_sum <span class="token operator">=</span> <span class="token punctuation">[</span>ps <span class="token operator">+</span> node<span class="token punctuation">.</span>val <span class="token keyword">for</span> ps <span class="token keyword">in</span> left <span class="token operator">+</span> right<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>node<span class="token punctuation">.</span>val<span class="token punctuation">]</span>
            <span class="token keyword">for</span> ps <span class="token keyword">in</span> path_sum<span class="token punctuation">:</span>
                <span class="token keyword">if</span> ps <span class="token operator">==</span> target<span class="token punctuation">:</span>
                    res <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">return</span> path_sum
        
        res <span class="token operator">=</span> <span class="token number">0</span>
        helper<span class="token punctuation">(</span>root<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_226-翻转二叉树" tabindex="-1"><a class="header-anchor" href="#_226-翻转二叉树"><span>226. 翻转二叉树</span></a></h3>`,11),un={href:"https://leetcode-cn.com/problems/invert-binary-tree/",title:"226. 翻转二叉树",target:"_blank",rel:"noopener noreferrer"},rn=t(`<p>一、题目</p><p>翻转一棵二叉树。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
            node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> node<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> node<span class="token punctuation">.</span>left
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_297-二叉树的序列化与反序列化" tabindex="-1"><a class="header-anchor" href="#_297-二叉树的序列化与反序列化"><span>297. 二叉树的序列化与反序列化</span></a></h3>`,6),kn={href:"https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/",title:"297. 二叉树的序列化与反序列化",target:"_blank",rel:"noopener noreferrer"},dn=t(`<p>一、题目</p><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>二、解析</p><p>层序遍历。</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Codec</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">serialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">&quot;&quot;&quot;Encodes a tree to a single string.&quot;&quot;&quot;</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token string">&quot;[]&quot;</span>
        
        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
        values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
            node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">:</span>
                values<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                values<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">&quot;null&quot;</span><span class="token punctuation">)</span>
        
        <span class="token keyword">return</span> <span class="token string">&quot;[&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;,&quot;</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>values<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span>

    <span class="token keyword">def</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">&quot;&quot;&quot;Decodes your encoded data to tree.&quot;&quot;&quot;</span>
        <span class="token keyword">if</span> data <span class="token operator">==</span> <span class="token string">&quot;[]&quot;</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

        values <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span>
        i <span class="token operator">=</span> <span class="token number">0</span>
        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>

        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
            node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            i <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">if</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">&quot;null&quot;</span><span class="token punctuation">:</span>
                node<span class="token punctuation">.</span>left <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            i <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">if</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">&quot;null&quot;</span><span class="token punctuation">:</span>
                node<span class="token punctuation">.</span>right <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_331-验证二叉树的前序序列化" tabindex="-1"><a class="header-anchor" href="#_331-验证二叉树的前序序列化"><span>331. 验证二叉树的前序序列化</span></a></h3>`,8),vn={href:"https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/",title:"331. 验证二叉树的前序序列化",target:"_blank",rel:"noopener noreferrer"},mn=t("<p>一、题目</p><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如<code>#</code>。</p><p>例如，上面的二叉树可以被序列化为字符串&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;，其中 # 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p>每个以逗号分隔的字符或为一个整数或为一个表示<code>null</code>指针的<code>&#39;#&#39;</code>。</p><p>二、解析</p>",6),bn={href:"https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/yan-zheng-er-cha-shu-de-qian-xu-xu-lie-hua-by-leet/",title:"Leetcode官方题解",target:"_blank",rel:"noopener noreferrer"},hn=t(`<p>栈模拟。代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isValidSerialization</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> preorder<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        slots <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token keyword">for</span> node <span class="token keyword">in</span> preorder<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">&#39;,&#39;</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            slots <span class="token operator">-=</span> <span class="token number">1</span>
            <span class="token keyword">if</span> slots <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            <span class="token keyword">if</span> node <span class="token operator">!=</span> <span class="token string">&#39;#&#39;</span><span class="token punctuation">:</span>
                slots <span class="token operator">+=</span> <span class="token number">2</span>
        
        <span class="token keyword">return</span> slots <span class="token operator">==</span> <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_606-根据二叉树创建字符串" tabindex="-1"><a class="header-anchor" href="#_606-根据二叉树创建字符串"><span>606. 根据二叉树创建字符串</span></a></h3>`,3),yn={href:"https://leetcode-cn.com/problems/construct-string-from-binary-tree/",title:"606. 根据二叉树创建字符串",target:"_blank",rel:"noopener noreferrer"},fn=t(`<p>一、题目</p><p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p><p>空节点则用一对空括号 &quot;()&quot; 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p><p>二、解析</p><p>递归比较简单。</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">tree2str</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> t<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">str</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> t<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token string">&#39;&#39;</span>
        <span class="token keyword">elif</span> <span class="token keyword">not</span> t<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> t<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> <span class="token keyword">not</span> t<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&#39;()(&#39;</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>tree2str<span class="token punctuation">(</span>t<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&#39;)&#39;</span>
        <span class="token keyword">elif</span> <span class="token keyword">not</span> t<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&#39;(&#39;</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>tree2str<span class="token punctuation">(</span>t<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&#39;)&#39;</span>
        <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&#39;(&#39;</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>tree2str<span class="token punctuation">(</span>t<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&#39;)(&#39;</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>tree2str<span class="token punctuation">(</span>t<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&#39;)&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_536-根据字符串创建二叉树" tabindex="-1"><a class="header-anchor" href="#_536-根据字符串创建二叉树"><span>536. 根据字符串创建二叉树</span></a></h3>`,7),wn={href:"https://leetcode-cn.com/problems/construct-binary-tree-from-string/",title:"536. 从字符串生成二叉树",target:"_blank",rel:"noopener noreferrer"},gn={href:"https://www.lintcode.com/problem/construct-binary-tree-from-string",title:"Lintcode 880. 字符串构造二叉树",target:"_blank",rel:"noopener noreferrer"},_n=t(`<p>一、题目</p><p>你需要根据一个由括号和整数组成的字符串中构造一颗二叉树。</p><p>输入的整个字符串表示一个二叉树。它包含一个整数，以及其后跟随的0~2对括号。该整数表示根的值，而一对括号里的字符串代表一个具有相同结构的子二叉树。</p><p>示例：</p><div class="language-纯文本 line-numbers-mode" data-ext="纯文本" data-title="纯文本"><pre class="language-纯文本"><code>输入: &quot;-4(2(3)(1))(6(5))&quot;
输入字符串对应的二叉树：
      -4
     /   \\
    2     6
   / \\   / 
  3   1 5 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong>：Leetcode需要会员，Lintcode不需要。</p><p>二、解析</p><p>迭代法和递归法。</p><p>1）迭代。</p>`,9),qn={href:"https://segmentfault.com/a/1190000016808160",title:"536. Construct Binary Tree from String 从带括号字符串构建二叉树",target:"_blank",rel:"noopener noreferrer"},xn=t(`<p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">str2tree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> s<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
            
        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        i <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
            ch <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token keyword">if</span> ch<span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">or</span> ch <span class="token operator">==</span> <span class="token string">&#39;-&#39;</span><span class="token punctuation">:</span>
                begin <span class="token operator">=</span> i
                <span class="token keyword">while</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">and</span> s<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    i <span class="token operator">+=</span> <span class="token number">1</span>
                node <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>begin<span class="token punctuation">:</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> stack<span class="token punctuation">:</span>
                    parent <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
                    <span class="token keyword">if</span> parent<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                        parent<span class="token punctuation">.</span>left <span class="token operator">=</span> node
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        parent<span class="token punctuation">.</span>right <span class="token operator">=</span> node
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
            <span class="token keyword">elif</span> ch <span class="token operator">==</span> <span class="token string">&#39;)&#39;</span><span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            i <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> stack<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）递归</p>`,3),Nn={href:"https://www.lintcode.com/problem/construct-binary-tree-from-string/note/187028",title:"Lintcode-xiongxiong",target:"_blank",rel:"noopener noreferrer"},Tn=t(`<p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">str2tree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> s<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        left_begin <span class="token operator">=</span> s<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">&#39;(&#39;</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> left_begin <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>

        left_end <span class="token operator">=</span> left_begin <span class="token operator">+</span> <span class="token number">1</span>
        num <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token keyword">while</span> left_end <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> s<span class="token punctuation">[</span>left_end<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">&#39;(&#39;</span><span class="token punctuation">:</span>
                num <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>left_end<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">&#39;)&#39;</span><span class="token punctuation">:</span>
                num <span class="token operator">-=</span> <span class="token number">1</span>
                <span class="token keyword">if</span> num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                    <span class="token keyword">break</span>
            left_end <span class="token operator">+=</span> <span class="token number">1</span>

        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span>left_begin<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>str2tree<span class="token punctuation">(</span>s<span class="token punctuation">[</span>left_begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span> left_end<span class="token punctuation">]</span><span class="token punctuation">)</span>
        right_end <span class="token operator">=</span> s<span class="token punctuation">.</span>rfind<span class="token punctuation">(</span><span class="token string">&#39;)&#39;</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> right_end <span class="token operator">&gt;</span> left_end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>
            root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>str2tree<span class="token punctuation">(</span>s<span class="token punctuation">[</span>left_end <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">:</span> right_end<span class="token punctuation">]</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_426-将二叉搜索树转化为排序的双向链表" tabindex="-1"><a class="header-anchor" href="#_426-将二叉搜索树转化为排序的双向链表"><span>426. 将二叉搜索树转化为排序的双向链表</span></a></h3>`,3),Sn={href:"https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/",title:"426. 将二叉搜索树转化为排序的双向链表",target:"_blank",rel:"noopener noreferrer"},Ln=t(`<p>一、题目</p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>二、解析</p><p>中序遍历，修改一下指针。</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">treeToDoublyList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">&#39;Node&#39;</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token string">&#39;Node&#39;</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> root <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> root

        pre <span class="token operator">=</span> head <span class="token operator">=</span> Node<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        node <span class="token operator">=</span> root
        <span class="token keyword">while</span> node <span class="token keyword">or</span> stack<span class="token punctuation">:</span>
            <span class="token keyword">if</span> node<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>left
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                node<span class="token punctuation">.</span>left <span class="token operator">=</span> pre
                pre<span class="token punctuation">.</span>right <span class="token operator">=</span> node
                pre <span class="token operator">=</span> node
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>right

        pre<span class="token punctuation">.</span>right <span class="token operator">=</span> head<span class="token punctuation">.</span>right
        head<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left <span class="token operator">=</span> pre
        <span class="token keyword">return</span> head<span class="token punctuation">.</span>right
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_109-有序链表转换二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_109-有序链表转换二叉搜索树"><span>109. 有序链表转换二叉搜索树</span></a></h3>`,7),Bn={href:"https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/",title:"109. 有序链表转换二叉搜索树",target:"_blank",rel:"noopener noreferrer"},In=t(`<p>一、题目</p><p>给定一个单链表，其中的元素按升序排序，将其转换为<strong>高度平衡的二叉搜索树</strong>。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</p><p>示例：</p><div class="language-纯文本 line-numbers-mode" data-ext="纯文本" data-title="纯文本"><pre class="language-纯文本"><code>给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \\
   -3   9
   /   /
 -10  5
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>二、解析</p><p>快慢指针 + 递归。</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">sortedListToBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> head<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token keyword">elif</span> <span class="token keyword">not</span> head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> TreeNode<span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        slow <span class="token operator">=</span> fast <span class="token operator">=</span> head
        pre <span class="token operator">=</span> <span class="token boolean">None</span>
        <span class="token keyword">while</span> fast <span class="token keyword">and</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span>
            pre <span class="token operator">=</span> slow
            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span>
            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span>
        pre<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>
        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>sortedListToBST<span class="token punctuation">(</span>head<span class="token punctuation">)</span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>sortedListToBST<span class="token punctuation">(</span>slow<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_669-修剪二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_669-修剪二叉搜索树"><span>669. 修剪二叉搜索树</span></a></h3>`,10),On={href:"https://leetcode-cn.com/problems/trim-a-binary-search-tree/",title:"669. 修剪二叉搜索树",target:"_blank",rel:"noopener noreferrer"},zn=t(`<p>一、题目</p><p>给定一个二叉搜索树，同时给定最小边界L和最大边界R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> L<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> R<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> L<span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>trimBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> R<span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>trimBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">)</span>

        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>trimBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">)</span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>trimBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">)</span>
        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_538-把二叉搜索树转换为累加树" tabindex="-1"><a class="header-anchor" href="#_538-把二叉搜索树转换为累加树"><span>538. 把二叉搜索树转换为累加树</span></a></h3>`,6),An={href:"https://leetcode-cn.com/problems/convert-bst-to-greater-tree/",title:"538. 把二叉搜索树转换为累加树",target:"_blank",rel:"noopener noreferrer"},Cn=t(`<p>一、题目</p><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">convertBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">convert</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span>
                <span class="token keyword">return</span> num
            node<span class="token punctuation">.</span>val <span class="token operator">+=</span> convert<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> num<span class="token punctuation">)</span>
            <span class="token keyword">return</span> convert<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
             
        convert<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_450-删除二叉搜索树中的节点" tabindex="-1"><a class="header-anchor" href="#_450-删除二叉搜索树中的节点"><span>450. 删除二叉搜索树中的节点</span></a></h3>`,6),Pn={href:"https://leetcode-cn.com/problems/delete-node-in-a-bst/",title:"450. 删除二叉搜索树中的节点",target:"_blank",rel:"noopener noreferrer"},Fn=t(`<p>一、题目</p><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：首先找到需要删除的节点；如果找到了，删除它。</p><p>说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p><p>二、解析</p><p>1）递归。</p><p>TODO</p><p>2）迭代。</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">delete_node_by_copy</span><span class="token punctuation">(</span>left_child<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
            child <span class="token operator">=</span> left_child
            parent <span class="token operator">=</span> node
            <span class="token keyword">while</span> child<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                parent <span class="token operator">=</span> child
                child <span class="token operator">=</span> child<span class="token punctuation">.</span>right
            <span class="token keyword">if</span> child <span class="token operator">==</span> left_child<span class="token punctuation">:</span>
                node<span class="token punctuation">.</span>val <span class="token operator">=</span> child<span class="token punctuation">.</span>val
                parent<span class="token punctuation">.</span>left <span class="token operator">=</span> child<span class="token punctuation">.</span>left
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                node<span class="token punctuation">.</span>val <span class="token operator">=</span> child<span class="token punctuation">.</span>val
                parent<span class="token punctuation">.</span>right <span class="token operator">=</span> child<span class="token punctuation">.</span>left
        
        parent <span class="token operator">=</span> <span class="token boolean">None</span>
        cur <span class="token operator">=</span> root
        <span class="token keyword">while</span> cur <span class="token keyword">and</span> cur<span class="token punctuation">.</span>val <span class="token operator">!=</span> key<span class="token punctuation">:</span>
            parent <span class="token operator">=</span> cur
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left <span class="token keyword">if</span> cur<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> key <span class="token keyword">else</span> cur<span class="token punctuation">.</span>right
        
        <span class="token keyword">if</span> cur <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> root
        <span class="token keyword">if</span> cur <span class="token keyword">is</span> root<span class="token punctuation">:</span>
            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">and</span> cur<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">None</span>
            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left <span class="token keyword">and</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                delete_node_by_copy<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> cur<span class="token punctuation">)</span>
                <span class="token keyword">return</span> root
            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                <span class="token keyword">return</span> cur<span class="token punctuation">.</span>left
            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                <span class="token keyword">return</span> cur<span class="token punctuation">.</span>right
        <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> cur<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            child <span class="token operator">=</span> cur<span class="token punctuation">.</span>left <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left <span class="token keyword">else</span> cur<span class="token punctuation">.</span>right
            <span class="token keyword">if</span> parent<span class="token punctuation">.</span>left <span class="token keyword">is</span> cur<span class="token punctuation">:</span>
                parent<span class="token punctuation">.</span>left <span class="token operator">=</span> child
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                parent<span class="token punctuation">.</span>right <span class="token operator">=</span> child
            <span class="token keyword">return</span> root
        
        delete_node_by_copy<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span> cur<span class="token punctuation">)</span>
        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_173-二叉搜索树迭代器" tabindex="-1"><a class="header-anchor" href="#_173-二叉搜索树迭代器"><span>173. 二叉搜索树迭代器</span></a></h3>`,11),Rn={href:"https://leetcode-cn.com/problems/binary-search-tree-iterator/",title:"173. 二叉搜索树迭代器",target:"_blank",rel:"noopener noreferrer"},Dn=t(`<p>一、题目</p><p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p><p>调用<code>next()</code>将返回二叉搜索树中的下一个最小的数。</p><p>二、解析</p><p>利用中序遍历。</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">BSTIterator</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>_inorder<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
    
    <span class="token keyword">def</span> <span class="token function">_inorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        cur <span class="token operator">=</span> node
        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left 

    <span class="token keyword">def</span> <span class="token function">next</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">&quot;&quot;&quot;
        @return the next smallest number
        &quot;&quot;&quot;</span>
        cur <span class="token operator">=</span> self<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
        val <span class="token operator">=</span> cur<span class="token punctuation">.</span>val
        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right
        self<span class="token punctuation">.</span>_inorder<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
        <span class="token keyword">return</span> val

    <span class="token keyword">def</span> <span class="token function">hasNext</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">&quot;&quot;&quot;
        @return whether we have a next smallest number
        &quot;&quot;&quot;</span>
        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_602-二叉树最大宽度" tabindex="-1"><a class="header-anchor" href="#_602-二叉树最大宽度"><span>602. 二叉树最大宽度</span></a></h3>`,7),Vn={href:"https://leetcode-cn.com/problems/maximum-width-of-binary-tree/",title:"662. 二叉树最大宽度",target:"_blank",rel:"noopener noreferrer"},jn=t(`<p>一、题目</p><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p><p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p><p>示例1</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,3,2,5,3,null,9]
输出：4
解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>二、解析</p>`,6),En={href:"https://leetcode-cn.com/problems/maximum-width-of-binary-tree/solution/er-cha-shu-zui-da-kuan-du-by-leetcode/",title:"Leetcode官方题解",target:"_blank",rel:"noopener noreferrer"},Mn=t(`<p>广度优先搜索或深度优先搜索。</p><p>1）广度优先搜索</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">widthOfBinaryTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        res <span class="token operator">=</span> <span class="token number">0</span>
        cur_depth <span class="token operator">=</span> left <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
            node<span class="token punctuation">,</span> depth<span class="token punctuation">,</span> pos <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">:</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> pos <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> pos <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">if</span> cur_depth <span class="token operator">!=</span> depth<span class="token punctuation">:</span>
                    cur_depth <span class="token operator">=</span> depth
                    left <span class="token operator">=</span> pos
                res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>pos <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）深度优先搜索</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">widthOfBinaryTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>ans <span class="token operator">=</span> <span class="token number">0</span>
        left <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> node<span class="token punctuation">:</span>
                left<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>depth<span class="token punctuation">,</span> pos<span class="token punctuation">)</span>
                self<span class="token punctuation">.</span>ans <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>ans<span class="token punctuation">,</span> pos <span class="token operator">-</span> left<span class="token punctuation">[</span>depth<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
                dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> pos <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
                dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> pos <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>

        dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>ans
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_222-完全二叉树的结点个数" tabindex="-1"><a class="header-anchor" href="#_222-完全二叉树的结点个数"><span>222. 完全二叉树的结点个数</span></a></h3>`,6),Gn={href:"https://leetcode-cn.com/problems/count-complete-tree-nodes/",title:"222. 完全二叉树的结点个数",target:"_blank",rel:"noopener noreferrer"},Hn=n("p",null,"一、题目",-1),Jn=n("p",null,"给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。",-1),Kn=n("p",null,"完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。",-1),Qn=n("p",null,"二、解析",-1),Un={href:"https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/wan-quan-er-cha-shu-de-jie-dian-ge-shu-by-leetcode/",title:"Leetcode官方题解",target:"_blank",rel:"noopener noreferrer"},Wn=t(`<p>遍历一次，或者使用二分搜索。</p><p>1）遍历一次，递归</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>countNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">if</span> root <span class="token keyword">else</span> <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）二分搜索</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">compute_depth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        d <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>left
            d <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> d

    <span class="token keyword">def</span> <span class="token function">exists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> idx<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> d<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> node<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">**</span>d <span class="token operator">-</span> <span class="token number">1</span>
        <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">:</span>
            mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
            <span class="token keyword">if</span> idx <span class="token operator">&gt;</span> mid<span class="token punctuation">:</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>right
                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>left
                right <span class="token operator">=</span> mid
        <span class="token keyword">return</span> node <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span>
        
    <span class="token keyword">def</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        
        d <span class="token operator">=</span> self<span class="token punctuation">.</span>compute_depth<span class="token punctuation">(</span>root<span class="token punctuation">)</span>
        <span class="token keyword">if</span> d <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">1</span>
        
        left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">**</span>d
        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>
            mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>mid<span class="token punctuation">,</span> d<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                right <span class="token operator">=</span> mid

        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span>d <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> left
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_958-二叉树的完全性检验" tabindex="-1"><a class="header-anchor" href="#_958-二叉树的完全性检验"><span>958. 二叉树的完全性检验</span></a></h3>`,6),Xn={href:"https://leetcode.cn/problems/check-completeness-of-a-binary-tree/",target:"_blank",rel:"noopener noreferrer"},Yn=t(`<p>一、题目</p><p>给定一个二叉树的 root ，确定它是否是一个 完全二叉树 。</p><p>在一个 完全二叉树 中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含 1 到 2h 节点之间的最后一级 h 。</p><p>示例 1：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>输入：root = [1,2,3,4,5,6]
输出：true
解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>二、解析</p><p>使用层序遍历【会往队列中添加空结点】。如果出现过空结点，就不能再有控结点。</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isCompleteTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>

        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 双向队列deque</span>
        none_node_flag <span class="token operator">=</span> <span class="token boolean">False</span>
        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
            node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">:</span>
                <span class="token keyword">if</span> none_node_flag<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                none_node_flag <span class="token operator">=</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1325-删除给定值的叶子节点" tabindex="-1"><a class="header-anchor" href="#_1325-删除给定值的叶子节点"><span>1325. 删除给定值的叶子节点</span></a></h3>`,10),Zn={href:"https://leetcode-cn.com/problems/delete-leaves-with-a-given-value/",title:"1325. 删除给定值的叶子节点",target:"_blank",rel:"noopener noreferrer"},$n=t("<p>一、题目</p><p>给你一棵以<code>root</code>为根的二叉树和一个整数<code>target</code>，请你删除所有值为<code>target</code>的叶子节点。</p><p>注意，一旦删除值为<code>target</code>的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是<code>target</code>，那么这个节点也应该被删除。</p><p>也就是说，你需要重复此过程直到不能继续删除。</p><p>二、解析</p>",5),ns={href:"https://leetcode-cn.com/problems/delete-leaves-with-a-given-value/solution/shan-chu-gei-ding-zhi-de-xie-zi-jie-dian-by-leet-2/",title:"Leetcode官方题解",target:"_blank",rel:"noopener noreferrer"},ss=t(`<p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">removeLeafNodes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> TreeNode<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>removeLeafNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>removeLeafNodes<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>left <span class="token keyword">and</span> <span class="token keyword">not</span> root<span class="token punctuation">.</span>right <span class="token keyword">and</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> target<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_99-恢复二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_99-恢复二叉搜索树"><span>99. 恢复二叉搜索树</span></a></h3>`,3),as={href:"https://leetcode-cn.com/problems/recover-binary-search-tree/",title:"99. 恢复二叉搜索树",target:"_blank",rel:"noopener noreferrer"},ps=t(`<p>一、题目</p><p>二叉搜索树中的两个节点被错误地交换。</p><p>请在不改变其结构的情况下，恢复这棵树。</p><p>二、解析</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">recoverTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">&quot;&quot;&quot;
        Do not return anything, modify root in-place instead.
        &quot;&quot;&quot;</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span>
        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        node <span class="token operator">=</span> root
        all_nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> stack <span class="token keyword">or</span> node<span class="token punctuation">:</span>
            <span class="token keyword">if</span> node<span class="token punctuation">:</span>
                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>left
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                all_nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>right
        
        wrong_nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>all_nodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> all_nodes<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>val <span class="token operator">&gt;</span> all_nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                wrong_nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>all_nodes<span class="token punctuation">[</span>i <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                wrong_nodes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>all_nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>

        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>wrong_nodes<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
            n1<span class="token punctuation">,</span> n2 <span class="token operator">=</span> wrong_nodes
            n1<span class="token punctuation">.</span>val<span class="token punctuation">,</span> n2<span class="token punctuation">.</span>val <span class="token operator">=</span> n2<span class="token punctuation">.</span>val<span class="token punctuation">,</span> n1<span class="token punctuation">.</span>val
        <span class="token keyword">elif</span> <span class="token builtin">len</span><span class="token punctuation">(</span>wrong_nodes<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">:</span>
            n1<span class="token punctuation">,</span> n2 <span class="token operator">=</span> wrong_nodes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> wrong_nodes<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>
            n1<span class="token punctuation">.</span>val<span class="token punctuation">,</span> n2<span class="token punctuation">.</span>val <span class="token operator">=</span> n2<span class="token punctuation">.</span>val<span class="token punctuation">,</span> n1<span class="token punctuation">.</span>val
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="lcr-143-树的子结构" tabindex="-1"><a class="header-anchor" href="#lcr-143-树的子结构"><span>LCR 143. 树的子结构</span></a></h3>`,7),ts={href:"https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/",target:"_blank",rel:"noopener noreferrer"},es=t(`<p>一、题目</p><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>给定的树 A:
     3
    / \\
   4   5
  / \\
 1   2
给定的树 B：
   4 
  /
 1

返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>二、解析</p><p>使用层序遍历。每个结点都判断一次是否是子结构。</p><p>代码如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> B<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">check</span><span class="token punctuation">(</span>root1<span class="token punctuation">,</span> root2<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> root1 <span class="token keyword">and</span> <span class="token keyword">not</span> root2<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">elif</span> root1 <span class="token keyword">and</span> <span class="token keyword">not</span> root2<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">elif</span> <span class="token keyword">not</span> root1 <span class="token keyword">and</span> root2<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
            <span class="token keyword">return</span> root1<span class="token punctuation">.</span>val <span class="token operator">==</span> root2<span class="token punctuation">.</span>val <span class="token keyword">and</span> check<span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">and</span> check<span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

        <span class="token keyword">if</span> <span class="token keyword">not</span> B<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        
        <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>A<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
            node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> check<span class="token punctuation">(</span>node<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

        <span class="token keyword">return</span> <span class="token boolean">False</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h2><h3 id="使用层序遍历构造二叉树" tabindex="-1"><a class="header-anchor" href="#使用层序遍历构造二叉树"><span>使用层序遍历构造二叉树</span></a></h3><p>一、题目</p><p>根据层序遍历构造二叉树。</p><p>举例：</p><div class="language-纯文本 line-numbers-mode" data-ext="纯文本" data-title="纯文本"><pre class="language-纯文本"><code>数组为：[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;null&quot;,&quot;null&quot;,&quot;4&quot;,&quot;5&quot;,&quot;null&quot;,&quot;null&quot;,&quot;null&quot;,&quot;null&quot;]

对应的二叉树：
        1
       / \\
      2   3
         / \\
        4   5
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>二、解析</p><p>1）迭代</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">create_binary_tree</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> data<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
        
    i <span class="token operator">=</span> <span class="token number">0</span>
    root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
        node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
        i <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">&quot;null&quot;</span><span class="token punctuation">:</span>
            node<span class="token punctuation">.</span>left <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        i <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">&quot;null&quot;</span><span class="token punctuation">:</span>
            node<span class="token punctuation">.</span>right <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>

    <span class="token keyword">return</span> root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,18);function os(cs,ls){const a=o("ExternalLinkIcon");return c(),l("div",null,[i(" more "),r,n("blockquote",null,[n("p",null,[n("a",k,[s("144. 二叉树的前序遍历"),p(a)])])]),d,n("blockquote",null,[n("p",null,[n("a",v,[s("94. 二叉树的中序遍历"),p(a)])])]),m,b,h,y,n("blockquote",null,[n("p",null,[n("a",f,[s("145. 二叉树的后序遍历"),p(a)])])]),w,n("blockquote",null,[n("p",null,[n("a",g,[s("102. 二叉树的层序遍历"),p(a)])])]),_,n("blockquote",null,[n("p",null,[n("a",q,[s("103. 二叉树的锯齿形层序遍历"),p(a)])])]),x,n("blockquote",null,[n("p",null,[n("a",N,[s("235. 二叉搜索树的最近公共祖先"),p(a)])])]),T,n("blockquote",null,[n("p",null,[n("a",S,[s("236. 二叉树的最近公共祖先"),p(a)])])]),L,n("blockquote",null,[n("p",null,[n("a",B,[s("257. 二叉树的所有路径"),p(a)])])]),I,n("blockquote",null,[n("p",null,[n("a",O,[s("112. 路径总和"),p(a)])])]),z,n("blockquote",null,[n("p",null,[n("a",A,[s("113. 路径总和 II"),p(a)])])]),C,n("blockquote",null,[n("p",null,[n("a",P,[s("437. 路径总和 III"),p(a)])])]),F,n("blockquote",null,[n("p",null,[n("a",R,[s("105. 从前序与中序遍历序列构造二叉树"),p(a)])])]),D,n("blockquote",null,[n("p",null,[n("a",V,[s("106. 从中序与后序遍历序列构造二叉树"),p(a)])])]),j,n("blockquote",null,[n("p",null,[n("a",E,[s("889. 根据前序和后序遍历构造二叉树"),p(a)])])]),M,n("blockquote",null,[n("p",null,[n("a",G,[s("1028. 从先序遍历还原二叉树"),p(a)])])]),H,n("blockquote",null,[n("p",null,[s("参考 "),n("a",J,[s("Leetcode官方题解"),p(a)])])]),K,n("blockquote",null,[n("p",null,[s("参考 "),n("a",Q,[s("Leetcode-Actonmic"),p(a)])])]),U,n("blockquote",null,[n("p",null,[n("a",W,[s("1008. 先序遍历构造二叉树"),p(a)])])]),X,n("blockquote",null,[n("p",null,[n("a",Y,[s("104. 二叉树的最大深度"),p(a)])])]),Z,n("blockquote",null,[n("p",null,[n("a",$,[s("110. 平衡二叉树"),p(a)])])]),nn,n("blockquote",null,[n("p",null,[n("a",sn,[s("543. 二叉树的直径"),p(a)])])]),an,n("blockquote",null,[n("p",null,[n("a",pn,[s("563. 二叉树的坡度"),p(a)])])]),tn,n("blockquote",null,[n("p",null,[n("a",en,[s("124. 二叉树中的最大路径和"),p(a)])])]),on,n("blockquote",null,[n("p",null,[n("a",cn,[s("437. 路径总和 III"),p(a)])])]),ln,n("blockquote",null,[n("p",null,[n("a",un,[s("226. 翻转二叉树"),p(a)])])]),rn,n("blockquote",null,[n("p",null,[n("a",kn,[s("297. 二叉树的序列化与反序列化"),p(a)])])]),dn,n("blockquote",null,[n("p",null,[n("a",vn,[s("331. 验证二叉树的前序序列化"),p(a)])])]),mn,n("blockquote",null,[n("p",null,[s("参考 "),n("a",bn,[s("Leetcode官方题解"),p(a)])])]),hn,n("blockquote",null,[n("p",null,[n("a",yn,[s("606. 根据二叉树创建字符串"),p(a)])])]),fn,n("blockquote",null,[n("p",null,[n("a",wn,[s("536. 从字符串生成二叉树"),p(a)]),n("a",gn,[s("Lintcode 880. 字符串构造二叉树"),p(a)])])]),_n,n("blockquote",null,[n("p",null,[n("a",qn,[s("536. Construct Binary Tree from String 从带括号字符串构建二叉树"),p(a)])])]),xn,n("blockquote",null,[n("p",null,[n("a",Nn,[s("Lintcode-xiongxiong"),p(a)])])]),Tn,n("blockquote",null,[n("p",null,[n("a",Sn,[s("426. 将二叉搜索树转化为排序的双向链表"),p(a)])])]),Ln,n("blockquote",null,[n("p",null,[n("a",Bn,[s("109. 有序链表转换二叉搜索树"),p(a)])])]),In,n("blockquote",null,[n("p",null,[n("a",On,[s("669. 修剪二叉搜索树"),p(a)])])]),zn,n("blockquote",null,[n("p",null,[n("a",An,[s("538. 把二叉搜索树转换为累加树"),p(a)])])]),Cn,n("blockquote",null,[n("p",null,[n("a",Pn,[s("450. 删除二叉搜索树中的节点"),p(a)])])]),Fn,n("blockquote",null,[n("p",null,[n("a",Rn,[s("173. 二叉搜索树迭代器"),p(a)])])]),Dn,n("blockquote",null,[n("p",null,[n("a",Vn,[s("662. 二叉树最大宽度"),p(a)])])]),jn,n("blockquote",null,[n("p",null,[s("参考 "),n("a",En,[s("Leetcode官方题解"),p(a)])])]),Mn,n("blockquote",null,[n("p",null,[n("a",Gn,[s("222. 完全二叉树的结点个数"),p(a)])])]),Hn,Jn,Kn,Qn,n("blockquote",null,[n("p",null,[s("参考 "),n("a",Un,[s("Leetcode官方题解"),p(a)])])]),Wn,n("blockquote",null,[n("p",null,[n("a",Xn,[s("958. 二叉树的完全性检验"),p(a)])])]),Yn,n("blockquote",null,[n("p",null,[n("a",Zn,[s("1325. 删除给定值的叶子节点"),p(a)])])]),$n,n("blockquote",null,[n("p",null,[s("参考 "),n("a",ns,[s("Leetcode官方题解"),p(a)])])]),ss,n("blockquote",null,[n("p",null,[n("a",as,[s("99. 恢复二叉搜索树"),p(a)])])]),ps,n("blockquote",null,[n("p",null,[n("a",ts,[s("LCR 143. 子结构判断"),p(a)])])]),es])}const rs=e(u,[["render",os],["__file","binary-tree.html.vue"]]);export{rs as default};
